# 阶段3实施计划：数据持久化与统计系统

## 🎯 阶段3目标

基于前两个阶段的成果，现在专注于数据管理和用户体验的深度优化：
- 实现跨平台数据持久化系统
- 创建完整的游戏统计和分析功能
- 开发成就系统和排行榜
- 实现游戏回放和数据导出功能

## 📋 详细任务清单

### 3.1 数据持久化系统开发 (2-3天)

#### 核心存储组件
- [ ] `PlatformStorage.kt` - 跨平台存储抽象
- [ ] `GameDataRepository.kt` - 数据仓库模式实现
- [ ] `SettingsRepository.kt` - 设置数据管理
- [ ] `StatisticsRepository.kt` - 统计数据管理

#### 数据模型设计
- [ ] `GameRecord.kt` - 游戏记录数据模型
- [ ] `PlayerStatistics.kt` - 玩家统计数据
- [ ] `Achievement.kt` - 成就数据模型
- [ ] `LeaderboardEntry.kt` - 排行榜条目

### 3.2 统计系统开发 (2-3天)

#### 统计分析组件
- [ ] `StatisticsManager.kt` - 统计数据管理器
- [ ] `GameAnalyzer.kt` - 游戏数据分析器
- [ ] `PerformanceTracker.kt` - 性能追踪器
- [ ] `TrendAnalyzer.kt` - 趋势分析器

#### 统计界面
- [ ] `StatisticsScreen.kt` - 统计主界面
- [ ] `ChartComponents.kt` - 图表组件
- [ ] `StatisticsCards.kt` - 统计卡片组件
- [ ] `FilterControls.kt` - 筛选控制组件

### 3.3 成就系统开发 (2天)

#### 成就核心组件
- [ ] `AchievementManager.kt` - 成就管理器
- [ ] `AchievementChecker.kt` - 成就检查器
- [ ] `AchievementDefinitions.kt` - 成就定义
- [ ] `AchievementNotification.kt` - 成就通知

#### 成就界面
- [ ] `AchievementsScreen.kt` - 成就界面
- [ ] `AchievementCard.kt` - 成就卡片
- [ ] `ProgressIndicator.kt` - 进度指示器
- [ ] `UnlockAnimation.kt` - 解锁动画

### 3.4 排行榜系统开发 (2天)

#### 排行榜组件
- [ ] `LeaderboardManager.kt` - 排行榜管理器
- [ ] `ScoreCalculator.kt` - 分数计算器
- [ ] `RankingSystem.kt` - 排名系统
- [ ] `LeaderboardSync.kt` - 数据同步(本地)

#### 排行榜界面
- [ ] `LeaderboardScreen.kt` - 排行榜界面
- [ ] `RankingList.kt` - 排名列表
- [ ] `PlayerRankCard.kt` - 玩家排名卡片
- [ ] `FilterTabs.kt` - 筛选标签

### 3.5 数据导出和回放系统 (1-2天)

#### 回放系统
- [ ] `GameRecorder.kt` - 游戏录制器
- [ ] `GameReplayer.kt` - 游戏回放器
- [ ] `ReplayData.kt` - 回放数据模型
- [ ] `ReplayControls.kt` - 回放控制组件

#### 数据导出
- [ ] `DataExporter.kt` - 数据导出器
- [ ] `ReportGenerator.kt` - 报告生成器
- [ ] `ShareManager.kt` - 分享管理器

## 🛠️ 技术实现要点

### 跨平台存储架构
```kotlin
// 存储抽象接口
expect class PlatformStorage {
    fun saveString(key: String, value: String)
    fun getString(key: String, defaultValue: String): String
    fun saveInt(key: String, value: Int)
    fun getInt(key: String, defaultValue: Int): Int
    fun saveLong(key: String, value: Long)
    fun getLong(key: String, defaultValue: Long): Long
    fun saveBoolean(key: String, value: Boolean)
    fun getBoolean(key: String, defaultValue: Boolean): Boolean
    fun remove(key: String)
    fun clear()
}

// Android实现
actual class PlatformStorage(private val context: Context) {
    private val prefs = context.getSharedPreferences("snake_game", Context.MODE_PRIVATE)
    
    actual fun saveString(key: String, value: String) {
        prefs.edit().putString(key, value).apply()
    }
    
    actual fun getString(key: String, defaultValue: String): String {
        return prefs.getString(key, defaultValue) ?: defaultValue
    }
}

// iOS实现
actual class PlatformStorage {
    actual fun saveString(key: String, value: String) {
        NSUserDefaults.standardUserDefaults.setObject(value, key)
    }
    
    actual fun getString(key: String, defaultValue: String): String {
        return NSUserDefaults.standardUserDefaults.stringForKey(key) ?: defaultValue
    }
}
```

### 数据仓库模式
```kotlin
// 数据仓库接口
interface GameDataRepository {
    suspend fun saveGameRecord(record: GameRecord)
    suspend fun getGameRecords(limit: Int = 100): List<GameRecord>
    suspend fun getPlayerStatistics(): PlayerStatistics
    suspend fun updateStatistics(statistics: PlayerStatistics)
    suspend fun clearAllData()
}

// 实现类
class GameDataRepositoryImpl(
    private val storage: PlatformStorage,
    private val jsonSerializer: Json
) : GameDataRepository {
    
    override suspend fun saveGameRecord(record: GameRecord) {
        val records = getGameRecords().toMutableList()
        records.add(0, record) // 添加到开头
        
        // 保持最多1000条记录
        if (records.size > 1000) {
            records.removeAt(records.size - 1)
        }
        
        val json = jsonSerializer.encodeToString(records)
        storage.saveString(KEY_GAME_RECORDS, json)
    }
    
    override suspend fun getGameRecords(limit: Int): List<GameRecord> {
        val json = storage.getString(KEY_GAME_RECORDS, "[]")
        val records = jsonSerializer.decodeFromString<List<GameRecord>>(json)
        return records.take(limit)
    }
}
```

### 统计分析系统
```kotlin
// 统计数据模型
data class PlayerStatistics(
    val totalGames: Int = 0,
    val totalScore: Long = 0,
    val highestScore: Int = 0,
    val totalPlayTime: Long = 0, // 毫秒
    val averageScore: Double = 0.0,
    val gamesWon: Int = 0,
    val longestSnake: Int = 0,
    val foodEaten: Int = 0,
    val effectsUsed: Int = 0,
    val gamesByMode: Map<GameMode, Int> = emptyMap(),
    val gamesByDifficulty: Map<Difficulty, Int> = emptyMap(),
    val dailyStats: Map<String, DailyStats> = emptyMap(), // 日期 -> 统计
    val achievements: Set<String> = emptySet()
)

// 统计管理器
class StatisticsManager(
    private val repository: GameDataRepository
) {
    
    suspend fun recordGameEnd(
        gameRecord: GameRecord,
        gameConfig: GameConfig
    ) {
        // 保存游戏记录
        repository.saveGameRecord(gameRecord)
        
        // 更新统计数据
        val currentStats = repository.getPlayerStatistics()
        val updatedStats = updateStatistics(currentStats, gameRecord, gameConfig)
        repository.updateStatistics(updatedStats)
    }
    
    private fun updateStatistics(
        current: PlayerStatistics,
        record: GameRecord,
        config: GameConfig
    ): PlayerStatistics {
        return current.copy(
            totalGames = current.totalGames + 1,
            totalScore = current.totalScore + record.finalScore,
            highestScore = maxOf(current.highestScore, record.finalScore),
            totalPlayTime = current.totalPlayTime + record.playTime,
            averageScore = (current.totalScore + record.finalScore).toDouble() / (current.totalGames + 1),
            longestSnake = maxOf(current.longestSnake, record.maxSnakeLength),
            foodEaten = current.foodEaten + record.foodEaten,
            gamesByMode = current.gamesByMode + (config.gameMode to (current.gamesByMode[config.gameMode] ?: 0) + 1),
            gamesByDifficulty = current.gamesByDifficulty + (config.difficulty to (current.gamesByDifficulty[config.difficulty] ?: 0) + 1)
        )
    }
}
```

### 成就系统设计
```kotlin
// 成就定义
sealed class Achievement(
    val id: String,
    val name: String,
    val description: String,
    val icon: String,
    val points: Int
) {
    abstract fun checkUnlock(statistics: PlayerStatistics, record: GameRecord?): Boolean
    
    // 分数相关成就
    class FirstScore(points: Int) : Achievement(
        "first_score", "初出茅庐", "获得第一分", "🎯", points
    ) {
        override fun checkUnlock(statistics: PlayerStatistics, record: GameRecord?): Boolean {
            return statistics.totalScore > 0
        }
    }
    
    class HighScore(private val targetScore: Int, points: Int) : Achievement(
        "high_score_$targetScore", "高分达人", "单局得分达到$targetScore", "🏆", points
    ) {
        override fun checkUnlock(statistics: PlayerStatistics, record: GameRecord?): Boolean {
            return statistics.highestScore >= targetScore
        }
    }
    
    // 游戏次数相关成就
    class GameCount(private val targetCount: Int, points: Int) : Achievement(
        "game_count_$targetCount", "坚持不懈", "累计游戏${targetCount}局", "🎮", points
    ) {
        override fun checkUnlock(statistics: PlayerStatistics, record: GameRecord?): Boolean {
            return statistics.totalGames >= targetCount
        }
    }
    
    // 特殊成就
    class PerfectGame : Achievement(
        "perfect_game", "完美游戏", "一局游戏中不撞墙", "✨", 50
    ) {
        override fun checkUnlock(statistics: PlayerStatistics, record: GameRecord?): Boolean {
            return record?.gameOverReason != GameState.GameOverReason.WALL_COLLISION
        }
    }
}

// 成就管理器
class AchievementManager(
    private val repository: GameDataRepository
) {
    
    private val allAchievements = listOf(
        Achievement.FirstScore(10),
        Achievement.HighScore(50, 20),
        Achievement.HighScore(100, 30),
        Achievement.HighScore(200, 50),
        Achievement.GameCount(10, 15),
        Achievement.GameCount(50, 25),
        Achievement.GameCount(100, 40),
        Achievement.PerfectGame()
    )
    
    suspend fun checkAchievements(
        gameRecord: GameRecord,
        gameConfig: GameConfig
    ): List<Achievement> {
        val statistics = repository.getPlayerStatistics()
        val unlockedAchievements = mutableListOf<Achievement>()
        
        allAchievements.forEach { achievement ->
            if (!statistics.achievements.contains(achievement.id) && 
                achievement.checkUnlock(statistics, gameRecord)) {
                unlockedAchievements.add(achievement)
            }
        }
        
        // 更新已解锁成就
        if (unlockedAchievements.isNotEmpty()) {
            val newAchievements = statistics.achievements + unlockedAchievements.map { it.id }
            val updatedStats = statistics.copy(achievements = newAchievements)
            repository.updateStatistics(updatedStats)
        }
        
        return unlockedAchievements
    }
}
```

## 📊 数据模型设计

### 游戏记录模型
```kotlin
@Serializable
data class GameRecord(
    val id: String = UUID.randomUUID().toString(),
    val timestamp: Long = System.currentTimeMillis(),
    val gameMode: GameMode,
    val difficulty: Difficulty,
    val finalScore: Int,
    val maxSnakeLength: Int,
    val playTime: Long, // 毫秒
    val foodEaten: Int,
    val effectsUsed: Int,
    val gameOverReason: GameState.GameOverReason,
    val replayData: ReplayData? = null
)

@Serializable
data class ReplayData(
    val moves: List<ReplayMove>,
    val foodPositions: List<Position>,
    val gameConfig: GameConfig
)

@Serializable
data class ReplayMove(
    val timestamp: Long,
    val direction: Direction,
    val snakePosition: List<Position>
)
```

### 排行榜模型
```kotlin
@Serializable
data class LeaderboardEntry(
    val playerName: String,
    val score: Int,
    val gameMode: GameMode,
    val difficulty: Difficulty,
    val timestamp: Long,
    val rank: Int = 0
)

data class Leaderboard(
    val entries: List<LeaderboardEntry>,
    val playerRank: Int?,
    val totalPlayers: Int
)
```

## 🎨 UI组件设计

### 统计界面组件
```kotlin
@Composable
fun StatisticsScreen(
    statistics: PlayerStatistics,
    onBackClick: () -> Unit
) {
    LazyColumn {
        item { OverviewCard(statistics) }
        item { ScoreChart(statistics) }
        item { GameModeBreakdown(statistics) }
        item { RecentGamesCard(statistics) }
        item { AchievementsPreview(statistics) }
    }
}

@Composable
fun OverviewCard(statistics: PlayerStatistics) {
    Card {
        Column {
            StatisticItem("总游戏数", statistics.totalGames.toString())
            StatisticItem("最高分", statistics.highestScore.toString())
            StatisticItem("平均分", "%.1f".format(statistics.averageScore))
            StatisticItem("总游戏时间", formatPlayTime(statistics.totalPlayTime))
        }
    }
}
```

## 🔧 性能优化策略

### 数据存储优化
1. **批量操作**: 减少频繁的I/O操作
2. **数据压缩**: 使用JSON压缩存储大量数据
3. **缓存机制**: 内存缓存常用数据
4. **异步操作**: 所有存储操作使用协程

### 统计计算优化
1. **增量更新**: 只计算变化的部分
2. **预计算**: 预先计算常用统计指标
3. **分页加载**: 大量数据分页处理
4. **后台计算**: 复杂统计在后台线程计算

## 📅 时间安排

### 第1-2天：数据持久化基础
- 实现跨平台存储抽象
- 创建数据仓库和基础数据模型
- 实现设置和游戏记录的保存加载

### 第3-4天：统计系统开发
- 开发统计管理器和分析器
- 创建统计界面和图表组件
- 实现数据可视化功能

### 第5-6天：成就系统实现
- 设计成就定义和检查逻辑
- 实现成就管理器和通知系统
- 创建成就界面和解锁动画

### 第7-8天：排行榜和回放
- 开发排行榜系统和界面
- 实现游戏回放录制和播放
- 添加数据导出和分享功能

### 第9-10天：集成测试和优化
- 全面测试数据持久化功能
- 性能优化和内存管理
- 跨平台兼容性验证

## 🎯 成功标准

### 功能完整性
- ✅ 数据持久化系统完全可用
- ✅ 统计功能准确完整
- ✅ 成就系统正常工作
- ✅ 排行榜功能完善

### 性能指标
- ✅ 数据保存/加载时间<100ms
- ✅ 统计计算时间<200ms
- ✅ 内存使用增长<20MB
- ✅ 应用启动时间增加<500ms

### 用户体验
- ✅ 数据永不丢失
- ✅ 统计信息直观易懂
- ✅ 成就系统有趣激励
- ✅ 界面响应流畅

---

**准备开始阶段3的数据管理之旅！** 🚀

让我们为贪吃蛇游戏构建完整的数据生态系统，提供深度的游戏体验和用户价值！