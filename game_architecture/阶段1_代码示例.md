# é˜¶æ®µ1ä»£ç ç¤ºä¾‹ï¼šæ ¸å¿ƒæ¶æ„ä¼˜åŒ–ä¸åŠŸèƒ½æ‰©å±•

## 1. æ¸¸æˆé…ç½®ç³»ç»Ÿ

### GameConfig æ•°æ®ç±»è®¾è®¡
```kotlin
data class GameConfig(
    val gameWidth: Int = 20,
    val gameHeight: Int = 20,
    val gameMode: GameMode = GameMode.CLASSIC,
    val difficulty: Difficulty = Difficulty.NORMAL,
    val initialSpeed: Long = 500L,
    val enableEffects: Boolean = true
) {
    // è®¡ç®—å±æ€§ - æ ¹æ®éš¾åº¦è°ƒæ•´é€Ÿåº¦
    fun getAdjustedSpeed(): Long {
        return when (difficulty) {
            Difficulty.EASY -> (initialSpeed * 1.5).toLong()
            Difficulty.NORMAL -> initialSpeed
            Difficulty.HARD -> (initialSpeed * 0.7).toLong()
            Difficulty.EXPERT -> (initialSpeed * 0.5).toLong()
        }
    }
    
    // éªŒè¯æ–¹æ³• - ç¡®ä¿é…ç½®æœ‰æ•ˆ
    fun isValid(): Boolean {
        return gameWidth > 5 && 
               gameHeight > 5 && 
               initialSpeed > 50
    }
}
```

**å­¦ä¹ è¦ç‚¹**ï¼š
- ä½¿ç”¨é»˜è®¤å‚æ•°æä¾›åˆç†çš„é»˜è®¤å€¼
- è®¡ç®—å±æ€§å°è£…å¤æ‚çš„ä¸šåŠ¡é€»è¾‘
- éªŒè¯æ–¹æ³•ç¡®ä¿æ•°æ®å®Œæ•´æ€§
- æ•°æ®ç±»è‡ªåŠ¨æä¾› `copy()` æ–¹æ³•ç”¨äºä¸å¯å˜æ›´æ–°

### å·¥å‚æ–¹æ³•æ¨¡å¼
```kotlin
companion object {
    fun createEasyConfig(): GameConfig {
        return GameConfig(
            gameWidth = 15,
            gameHeight = 15,
            difficulty = Difficulty.EASY,
            initialSpeed = 600L,
            enableEffects = false
        )
    }
    
    fun createExpertConfig(): GameConfig {
        return GameConfig(
            gameWidth = 25,
            gameHeight = 25,
            difficulty = Difficulty.EXPERT,
            initialSpeed = 200L,
            enableEffects = true
        )
    }
}
```

**å­¦ä¹ è¦ç‚¹**ï¼š
- å·¥å‚æ–¹æ³•æä¾›é¢„å®šä¹‰çš„é…ç½®
- ç®€åŒ–å®¢æˆ·ç«¯ä»£ç 
- ä¾¿äºç»´æŠ¤å’Œæµ‹è¯•

## 2. æšä¸¾ç±»çš„é«˜çº§åº”ç”¨

### å¸¦å‚æ•°å’Œæ–¹æ³•çš„æšä¸¾ç±»
```kotlin
enum class Difficulty(
    val displayName: String,
    val speedMultiplier: Float,
    val scoreMultiplier: Float,
    val initialSnakeLength: Int
) {
    EASY("ç®€å•", 1.5f, 0.8f, 2),
    NORMAL("æ™®é€š", 1.0f, 1.0f, 3),
    HARD("å›°éš¾", 0.7f, 1.5f, 4),
    EXPERT("ä¸“å®¶", 0.5f, 2.0f, 5);
    
    // æšä¸¾ç±»ä¸­çš„æ–¹æ³•
    fun calculateSpeed(baseSpeed: Long): Long {
        return (baseSpeed * speedMultiplier).toLong().coerceAtLeast(50L)
    }
    
    fun calculateScore(baseScore: Int): Int {
        return (baseScore * scoreMultiplier).toInt().coerceAtLeast(1)
    }
    
    // çŠ¶æ€è½¬æ¢æ–¹æ³•
    fun getNextDifficulty(): Difficulty? {
        return when (this) {
            EASY -> NORMAL
            NORMAL -> HARD
            HARD -> EXPERT
            EXPERT -> null
        }
    }
}
```

**å­¦ä¹ è¦ç‚¹**ï¼š
- æšä¸¾å€¼å¯ä»¥æœ‰ä¸åŒçš„å‚æ•°
- æšä¸¾ç±»å¯ä»¥åŒ…å«æ–¹æ³•å’Œè®¡ç®—é€»è¾‘
- ä½¿ç”¨ `coerceAtLeast()` å’Œ `coerceAtMost()` ç¡®ä¿å€¼åœ¨åˆç†èŒƒå›´å†…
- æšä¸¾ç±»æä¾›ç±»å‹å®‰å…¨çš„çŠ¶æ€è½¬æ¢

### æšä¸¾ç±»çš„ä¸šåŠ¡é€»è¾‘å°è£…
```kotlin
enum class GameMode(
    val displayName: String,
    val description: String,
    val icon: String
) {
    CLASSIC("ç»å…¸æ¨¡å¼", "ä¼ ç»Ÿè´ªåƒè›‡æ¸¸æˆ", "ğŸ"),
    BORDERLESS("æ— å¢™æ¨¡å¼", "è›‡å¯ä»¥ç©¿è¶Šè¾¹ç•Œ", "ğŸŒ€"),
    OBSTACLES("éšœç¢ç‰©æ¨¡å¼", "æ¸¸æˆåŒºåŸŸä¸­æœ‰é™æ€éšœç¢ç‰©", "ğŸ§±"),
    TIME_CHALLENGE("æ—¶é—´æŒ‘æˆ˜", "åœ¨é™å®šæ—¶é—´å†…è·å¾—é«˜åˆ†", "â°");
    
    // ä¸šåŠ¡é€»è¾‘æ–¹æ³•
    fun requiresBoundaryCollision(): Boolean {
        return this != BORDERLESS
    }
    
    fun supportsObstacles(): Boolean {
        return this == OBSTACLES
    }
    
    fun hasTimeLimit(): Boolean {
        return this == TIME_CHALLENGE
    }
    
    // æ¨èé…ç½®
    fun getRecommendedSize(): Pair<Int, Int> {
        return when (this) {
            CLASSIC -> Pair(20, 20)
            BORDERLESS -> Pair(18, 18)
            OBSTACLES -> Pair(22, 22)
            TIME_CHALLENGE -> Pair(20, 20)
        }
    }
}
```

**å­¦ä¹ è¦ç‚¹**ï¼š
- å°†ç›¸å…³çš„ä¸šåŠ¡é€»è¾‘å°è£…åœ¨æšä¸¾ç±»ä¸­
- ä½¿ç”¨æè¿°æ€§çš„æ–¹æ³•åæé«˜ä»£ç å¯è¯»æ€§
- æšä¸¾ç±»å¯ä»¥è¿”å›å¤æ‚çš„æ•°æ®ç»“æ„

## 3. é£Ÿç‰©ç³»ç»Ÿçš„è®¾è®¡

### å¸¦æ•ˆæœå·¥å‚çš„æšä¸¾ç±»
```kotlin
enum class FoodType(
    val displayName: String,
    val points: Int,
    val color: Color,
    val rarity: Float,
    val effectFactory: () -> FoodEffect?
) {
    REGULAR("æ™®é€šé£Ÿç‰©", 1, Color.Red, 0.7f, { null }),
    BONUS("å¥–åŠ±é£Ÿç‰©", 5, Color.Gold, 0.2f, { null }),
    SPEED_UP("åŠ é€Ÿé£Ÿç‰©", 2, Color.Blue, 0.15f, { SpeedUpEffect(3000L) }),
    GHOST("å¹½çµé£Ÿç‰©", 3, Color.Gray, 0.08f, { GhostEffect(5000L) });
    
    // å·¥å‚æ–¹æ³•
    fun createEffect(): FoodEffect? {
        return effectFactory()
    }
    
    // æ£€æŸ¥æ–¹æ³•
    fun hasEffect(): Boolean {
        return effectFactory() != null
    }
}
```

**å­¦ä¹ è¦ç‚¹**ï¼š
- ä½¿ç”¨å‡½æ•°ç±»å‹å‚æ•°å®ç°å·¥å‚æ¨¡å¼
- å»¶è¿Ÿåˆ›å»ºå¯¹è±¡ï¼Œé¿å…ä¸å¿…è¦çš„å†…å­˜åˆ†é…
- ç¨€æœ‰åº¦ç³»ç»Ÿæ”¯æŒåŠ æƒéšæœºé€‰æ‹©

### åŠ æƒéšæœºé€‰æ‹©ç®—æ³•
```kotlin
companion object {
    fun randomType(enableEffects: Boolean = true): FoodType {
        val availableTypes = if (enableEffects) {
            values().toList()
        } else {
            listOf(REGULAR, BONUS)
        }
        
        // è®¡ç®—æ€»æƒé‡
        val totalWeight = availableTypes.sumOf { it.rarity.toDouble() }
        
        // ç”Ÿæˆéšæœºæ•°
        val random = kotlin.random.Random.nextDouble(totalWeight)
        
        // æ ¹æ®æƒé‡é€‰æ‹©
        var currentWeight = 0.0
        for (type in availableTypes) {
            currentWeight += type.rarity
            if (random <= currentWeight) {
                return type
            }
        }
        
        return REGULAR // é»˜è®¤å€¼
    }
}
```

**å­¦ä¹ è¦ç‚¹**ï¼š
- åŠ æƒéšæœºç®—æ³•çš„å®ç°
- ä½¿ç”¨ `sumOf()` å‡½æ•°è®¡ç®—æ€»æƒé‡
- ç´¯ç§¯æƒé‡çš„é€‰æ‹©ç­–ç•¥

## 4. æ•ˆæœç³»ç»Ÿè®¾è®¡

### æ¥å£å®šä¹‰
```kotlin
interface FoodEffect {
    val duration: Long
    val type: EffectType
    var startTime: Long
    
    fun applyEffect(
        currentSpeed: Long,
        canPassThroughWalls: Boolean,
        canPassThroughSelf: Boolean
    ): EffectResult
    
    fun isExpired(currentTime: Long): Boolean {
        return currentTime - startTime >= duration
    }
}
```

**å­¦ä¹ è¦ç‚¹**ï¼š
- æ¥å£å®šä¹‰äº†é€šç”¨çš„è¡Œä¸ºå¥‘çº¦
- é»˜è®¤æ–¹æ³•å®ç°å‡å°‘é‡å¤ä»£ç 
- å‚æ•°åŒ–çš„æ•ˆæœåº”ç”¨æ–¹æ³•

### å…·ä½“æ•ˆæœå®ç°
```kotlin
class SpeedUpEffect(
    override val duration: Long = 3000L
) : FoodEffect {
    override val type = EffectType.SPEED_UP
    override var startTime: Long = 0L
    
    override fun applyEffect(
        currentSpeed: Long,
        canPassThroughWalls: Boolean,
        canPassThroughSelf: Boolean
    ): EffectResult {
        val newSpeed = (currentSpeed * 0.7f).toLong().coerceAtLeast(50L)
        return EffectResult(newSpeed, canPassThroughWalls, canPassThroughSelf)
    }
}
```

**å­¦ä¹ è¦ç‚¹**ï¼š
- æ¯ä¸ªæ•ˆæœéƒ½æ˜¯ç‹¬ç«‹çš„ç±»
- ä½¿ç”¨æ•°å­¦è¿ç®—è°ƒæ•´æ¸¸æˆå‚æ•°
- è¾¹ç•Œæ£€æŸ¥ç¡®ä¿å‚æ•°åœ¨åˆç†èŒƒå›´å†…

### æ•ˆæœç®¡ç†å™¨
```kotlin
class EffectManager {
    private val activeEffects = mutableListOf<FoodEffect>()
    
    fun addEffect(effect: FoodEffect, currentTime: Long) {
        effect.startTime = currentTime
        
        // ç§»é™¤ç›¸åŒç±»å‹çš„æ—§æ•ˆæœ
        activeEffects.removeAll { it.type == effect.type }
        
        // æ·»åŠ æ–°æ•ˆæœ
        activeEffects.add(effect)
    }
    
    fun applyAllEffects(baseSpeed: Long, currentTime: Long): EffectResult {
        // æ¸…ç†è¿‡æœŸæ•ˆæœ
        activeEffects.removeAll { it.isExpired(currentTime) }
        
        // é“¾å¼åº”ç”¨æ‰€æœ‰æ•ˆæœ
        var result = EffectResult(baseSpeed, false, false)
        
        for (effect in activeEffects) {
            result = effect.applyEffect(
                result.speed,
                result.canPassThroughWalls,
                result.canPassThroughSelf
            )
        }
        
        return result
    }
}
```

**å­¦ä¹ è¦ç‚¹**ï¼š
- ç®¡ç†å™¨æ¨¡å¼é›†ä¸­å¤„ç†å¤æ‚é€»è¾‘
- è‡ªåŠ¨æ¸…ç†è¿‡æœŸæ•ˆæœ
- é“¾å¼åº”ç”¨å¤šä¸ªæ•ˆæœ
- é˜²æ­¢ç›¸åŒç±»å‹æ•ˆæœé‡å¤

## 5. ä¸å¯å˜æ•°æ®ç»“æ„

### æ•ˆæœç»“æœæ•°æ®ç±»
```kotlin
data class EffectResult(
    val speed: Long,
    val canPassThroughWalls: Boolean,
    val canPassThroughSelf: Boolean
)
```

**å­¦ä¹ è¦ç‚¹**ï¼š
- ä¸å¯å˜æ•°æ®ç±»ç¡®ä¿çº¿ç¨‹å®‰å…¨
- æ¸…æ™°çš„æ•°æ®ä¼ é€’å¥‘çº¦
- ä¾¿äºæµ‹è¯•å’Œè°ƒè¯•

## 6. æ‰©å±•å‡½æ•°çš„ä½¿ç”¨

### ä¸ºç°æœ‰ç±»æ·»åŠ åŠŸèƒ½
```kotlin
// ä¸ºLongç±»å‹æ·»åŠ æ—¶é—´æ ¼å¼åŒ–æ‰©å±•
fun Long.toTimeString(): String {
    val seconds = this / 1000
    val minutes = seconds / 60
    val remainingSeconds = seconds % 60
    return "${minutes}:${remainingSeconds.toString().padStart(2, '0')}"
}

// ä½¿ç”¨ç¤ºä¾‹
val remainingTime = effect.getRemainingTime(currentTime)
val timeString = remainingTime.toTimeString() // "2:30"
```

**å­¦ä¹ è¦ç‚¹**ï¼š
- æ‰©å±•å‡½æ•°ä¸ºç°æœ‰ç±»å‹æ·»åŠ æ–°åŠŸèƒ½
- ä¸ä¿®æ”¹åŸå§‹ç±»çš„æƒ…å†µä¸‹å¢å¼ºåŠŸèƒ½
- æé«˜ä»£ç çš„å¯è¯»æ€§å’Œå¤ç”¨æ€§

## æ€»ç»“

è¿™äº›ä»£ç ç¤ºä¾‹å±•ç¤ºäº†ï¼š
1. **æ•°æ®ç±»çš„é«˜çº§ç”¨æ³•**ï¼šè®¡ç®—å±æ€§ã€éªŒè¯æ–¹æ³•ã€å·¥å‚æ–¹æ³•
2. **æšä¸¾ç±»çš„å¼ºå¤§åŠŸèƒ½**ï¼šå‚æ•°åŒ–æšä¸¾ã€ä¸šåŠ¡é€»è¾‘å°è£…ã€çŠ¶æ€è½¬æ¢
3. **æ¥å£å’Œå®ç°åˆ†ç¦»**ï¼šæ•ˆæœç³»ç»Ÿçš„å¯æ‰©å±•è®¾è®¡
4. **ç®¡ç†å™¨æ¨¡å¼**ï¼šé›†ä¸­å¤„ç†å¤æ‚çš„ä¸šåŠ¡é€»è¾‘
5. **å‡½æ•°å¼ç¼–ç¨‹å…ƒç´ **ï¼šé«˜é˜¶å‡½æ•°ã€lambdaè¡¨è¾¾å¼
6. **ä¸å¯å˜æ•°æ®ç»“æ„**ï¼šç¡®ä¿æ•°æ®ä¸€è‡´æ€§å’Œçº¿ç¨‹å®‰å…¨

è¿™äº›æŠ€æœ¯ä¸ºæ¸¸æˆç³»ç»Ÿæä¾›äº†åšå®çš„åŸºç¡€ï¼Œä½¿ä»£ç æ—¢çµæ´»åˆå¯ç»´æŠ¤ã€‚