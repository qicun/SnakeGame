# 阶段1代码示例：核心架构优化与功能扩展

## 1. 游戏配置系统

### GameConfig 数据类设计
```kotlin
data class GameConfig(
    val gameWidth: Int = 20,
    val gameHeight: Int = 20,
    val gameMode: GameMode = GameMode.CLASSIC,
    val difficulty: Difficulty = Difficulty.NORMAL,
    val initialSpeed: Long = 500L,
    val enableEffects: Boolean = true
) {
    // 计算属性 - 根据难度调整速度
    fun getAdjustedSpeed(): Long {
        return when (difficulty) {
            Difficulty.EASY -> (initialSpeed * 1.5).toLong()
            Difficulty.NORMAL -> initialSpeed
            Difficulty.HARD -> (initialSpeed * 0.7).toLong()
            Difficulty.EXPERT -> (initialSpeed * 0.5).toLong()
        }
    }
    
    // 验证方法 - 确保配置有效
    fun isValid(): Boolean {
        return gameWidth > 5 && 
               gameHeight > 5 && 
               initialSpeed > 50
    }
}
```

**学习要点**：
- 使用默认参数提供合理的默认值
- 计算属性封装复杂的业务逻辑
- 验证方法确保数据完整性
- 数据类自动提供 `copy()` 方法用于不可变更新

### 工厂方法模式
```kotlin
companion object {
    fun createEasyConfig(): GameConfig {
        return GameConfig(
            gameWidth = 15,
            gameHeight = 15,
            difficulty = Difficulty.EASY,
            initialSpeed = 600L,
            enableEffects = false
        )
    }
    
    fun createExpertConfig(): GameConfig {
        return GameConfig(
            gameWidth = 25,
            gameHeight = 25,
            difficulty = Difficulty.EXPERT,
            initialSpeed = 200L,
            enableEffects = true
        )
    }
}
```

**学习要点**：
- 工厂方法提供预定义的配置
- 简化客户端代码
- 便于维护和测试

## 2. 枚举类的高级应用

### 带参数和方法的枚举类
```kotlin
enum class Difficulty(
    val displayName: String,
    val speedMultiplier: Float,
    val scoreMultiplier: Float,
    val initialSnakeLength: Int
) {
    EASY("简单", 1.5f, 0.8f, 2),
    NORMAL("普通", 1.0f, 1.0f, 3),
    HARD("困难", 0.7f, 1.5f, 4),
    EXPERT("专家", 0.5f, 2.0f, 5);
    
    // 枚举类中的方法
    fun calculateSpeed(baseSpeed: Long): Long {
        return (baseSpeed * speedMultiplier).toLong().coerceAtLeast(50L)
    }
    
    fun calculateScore(baseScore: Int): Int {
        return (baseScore * scoreMultiplier).toInt().coerceAtLeast(1)
    }
    
    // 状态转换方法
    fun getNextDifficulty(): Difficulty? {
        return when (this) {
            EASY -> NORMAL
            NORMAL -> HARD
            HARD -> EXPERT
            EXPERT -> null
        }
    }
}
```

**学习要点**：
- 枚举值可以有不同的参数
- 枚举类可以包含方法和计算逻辑
- 使用 `coerceAtLeast()` 和 `coerceAtMost()` 确保值在合理范围内
- 枚举类提供类型安全的状态转换

### 枚举类的业务逻辑封装
```kotlin
enum class GameMode(
    val displayName: String,
    val description: String,
    val icon: String
) {
    CLASSIC("经典模式", "传统贪吃蛇游戏", "🐍"),
    BORDERLESS("无墙模式", "蛇可以穿越边界", "🌀"),
    OBSTACLES("障碍物模式", "游戏区域中有静态障碍物", "🧱"),
    TIME_CHALLENGE("时间挑战", "在限定时间内获得高分", "⏰");
    
    // 业务逻辑方法
    fun requiresBoundaryCollision(): Boolean {
        return this != BORDERLESS
    }
    
    fun supportsObstacles(): Boolean {
        return this == OBSTACLES
    }
    
    fun hasTimeLimit(): Boolean {
        return this == TIME_CHALLENGE
    }
    
    // 推荐配置
    fun getRecommendedSize(): Pair<Int, Int> {
        return when (this) {
            CLASSIC -> Pair(20, 20)
            BORDERLESS -> Pair(18, 18)
            OBSTACLES -> Pair(22, 22)
            TIME_CHALLENGE -> Pair(20, 20)
        }
    }
}
```

**学习要点**：
- 将相关的业务逻辑封装在枚举类中
- 使用描述性的方法名提高代码可读性
- 枚举类可以返回复杂的数据结构

## 3. 食物系统的设计

### 带效果工厂的枚举类
```kotlin
enum class FoodType(
    val displayName: String,
    val points: Int,
    val color: Color,
    val rarity: Float,
    val effectFactory: () -> FoodEffect?
) {
    REGULAR("普通食物", 1, Color.Red, 0.7f, { null }),
    BONUS("奖励食物", 5, Color.Gold, 0.2f, { null }),
    SPEED_UP("加速食物", 2, Color.Blue, 0.15f, { SpeedUpEffect(3000L) }),
    GHOST("幽灵食物", 3, Color.Gray, 0.08f, { GhostEffect(5000L) });
    
    // 工厂方法
    fun createEffect(): FoodEffect? {
        return effectFactory()
    }
    
    // 检查方法
    fun hasEffect(): Boolean {
        return effectFactory() != null
    }
}
```

**学习要点**：
- 使用函数类型参数实现工厂模式
- 延迟创建对象，避免不必要的内存分配
- 稀有度系统支持加权随机选择

### 加权随机选择算法
```kotlin
companion object {
    fun randomType(enableEffects: Boolean = true): FoodType {
        val availableTypes = if (enableEffects) {
            values().toList()
        } else {
            listOf(REGULAR, BONUS)
        }
        
        // 计算总权重
        val totalWeight = availableTypes.sumOf { it.rarity.toDouble() }
        
        // 生成随机数
        val random = kotlin.random.Random.nextDouble(totalWeight)
        
        // 根据权重选择
        var currentWeight = 0.0
        for (type in availableTypes) {
            currentWeight += type.rarity
            if (random <= currentWeight) {
                return type
            }
        }
        
        return REGULAR // 默认值
    }
}
```

**学习要点**：
- 加权随机算法的实现
- 使用 `sumOf()` 函数计算总权重
- 累积权重的选择策略

## 4. 效果系统设计

### 接口定义
```kotlin
interface FoodEffect {
    val duration: Long
    val type: EffectType
    var startTime: Long
    
    fun applyEffect(
        currentSpeed: Long,
        canPassThroughWalls: Boolean,
        canPassThroughSelf: Boolean
    ): EffectResult
    
    fun isExpired(currentTime: Long): Boolean {
        return currentTime - startTime >= duration
    }
}
```

**学习要点**：
- 接口定义了通用的行为契约
- 默认方法实现减少重复代码
- 参数化的效果应用方法

### 具体效果实现
```kotlin
class SpeedUpEffect(
    override val duration: Long = 3000L
) : FoodEffect {
    override val type = EffectType.SPEED_UP
    override var startTime: Long = 0L
    
    override fun applyEffect(
        currentSpeed: Long,
        canPassThroughWalls: Boolean,
        canPassThroughSelf: Boolean
    ): EffectResult {
        val newSpeed = (currentSpeed * 0.7f).toLong().coerceAtLeast(50L)
        return EffectResult(newSpeed, canPassThroughWalls, canPassThroughSelf)
    }
}
```

**学习要点**：
- 每个效果都是独立的类
- 使用数学运算调整游戏参数
- 边界检查确保参数在合理范围内

### 效果管理器
```kotlin
class EffectManager {
    private val activeEffects = mutableListOf<FoodEffect>()
    
    fun addEffect(effect: FoodEffect, currentTime: Long) {
        effect.startTime = currentTime
        
        // 移除相同类型的旧效果
        activeEffects.removeAll { it.type == effect.type }
        
        // 添加新效果
        activeEffects.add(effect)
    }
    
    fun applyAllEffects(baseSpeed: Long, currentTime: Long): EffectResult {
        // 清理过期效果
        activeEffects.removeAll { it.isExpired(currentTime) }
        
        // 链式应用所有效果
        var result = EffectResult(baseSpeed, false, false)
        
        for (effect in activeEffects) {
            result = effect.applyEffect(
                result.speed,
                result.canPassThroughWalls,
                result.canPassThroughSelf
            )
        }
        
        return result
    }
}
```

**学习要点**：
- 管理器模式集中处理复杂逻辑
- 自动清理过期效果
- 链式应用多个效果
- 防止相同类型效果重复

## 5. 不可变数据结构

### 效果结果数据类
```kotlin
data class EffectResult(
    val speed: Long,
    val canPassThroughWalls: Boolean,
    val canPassThroughSelf: Boolean
)
```

**学习要点**：
- 不可变数据类确保线程安全
- 清晰的数据传递契约
- 便于测试和调试

## 6. 扩展函数的使用

### 为现有类添加功能
```kotlin
// 为Long类型添加时间格式化扩展
fun Long.toTimeString(): String {
    val seconds = this / 1000
    val minutes = seconds / 60
    val remainingSeconds = seconds % 60
    return "${minutes}:${remainingSeconds.toString().padStart(2, '0')}"
}

// 使用示例
val remainingTime = effect.getRemainingTime(currentTime)
val timeString = remainingTime.toTimeString() // "2:30"
```

**学习要点**：
- 扩展函数为现有类型添加新功能
- 不修改原始类的情况下增强功能
- 提高代码的可读性和复用性

## 总结

这些代码示例展示了：
1. **数据类的高级用法**：计算属性、验证方法、工厂方法
2. **枚举类的强大功能**：参数化枚举、业务逻辑封装、状态转换
3. **接口和实现分离**：效果系统的可扩展设计
4. **管理器模式**：集中处理复杂的业务逻辑
5. **函数式编程元素**：高阶函数、lambda表达式
6. **不可变数据结构**：确保数据一致性和线程安全

这些技术为游戏系统提供了坚实的基础，使代码既灵活又可维护。