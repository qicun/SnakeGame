# 阶段1技术要点：核心架构优化与功能扩展

## 核心概念

### 1. 配置系统设计模式

#### 数据类（Data Class）的高级应用
```kotlin
data class GameConfig(
    val gameWidth: Int = 20,
    val gameHeight: Int = 20,
    val gameMode: GameMode = GameMode.CLASSIC,
    val difficulty: Difficulty = Difficulty.NORMAL
) {
    // 计算属性
    fun getAdjustedSpeed(): Long {
        return when (difficulty) {
            Difficulty.EASY -> (initialSpeed * 1.5).toLong()
            // ...
        }
    }
    
    // 验证逻辑
    fun isValid(): Boolean {
        return gameWidth > 5 && gameHeight > 5
    }
}
```

**学习要点**：
- 数据类不仅可以存储数据，还可以包含计算逻辑
- 使用默认参数提供合理的默认值
- 添加验证方法确保数据的有效性
- 使用伴生对象提供工厂方法

### 2. 枚举类（Enum Class）的高级特性

#### 带参数的枚举类
```kotlin
enum class Difficulty(
    val displayName: String,
    val speedMultiplier: Float,
    val scoreMultiplier: Float
) {
    EASY("简单", 1.5f, 0.8f),
    NORMAL("普通", 1.0f, 1.0f),
    HARD("困难", 0.7f, 1.5f);
    
    // 枚举类中的方法
    fun calculateSpeed(baseSpeed: Long): Long {
        return (baseSpeed * speedMultiplier).toLong()
    }
}
```

**学习要点**：
- 枚举类可以有构造参数和方法
- 每个枚举值都是该类的实例
- 可以在枚举类中定义通用的业务逻辑
- 使用枚举类替代常量，提供类型安全

### 3. 策略模式（Strategy Pattern）

#### 游戏模式策略接口
```kotlin
interface GameModeStrategy {
    fun handleMovement(snake: Snake, boundaries: Boundaries): Snake
    fun checkCollision(snake: Snake, boundaries: Boundaries): Boolean
    fun generateObstacles(gameArea: GameArea): List<Obstacle>
}

// 具体策略实现
class ClassicModeStrategy : GameModeStrategy {
    override fun handleMovement(snake: Snake, boundaries: Boundaries): Snake {
        // 经典模式的移动逻辑
        return snake.move()
    }
    
    override fun checkCollision(snake: Snake, boundaries: Boundaries): Boolean {
        // 检查边界碰撞
        return snake.head.x < 0 || snake.head.x >= boundaries.width
    }
}

class BorderlessModeStrategy : GameModeStrategy {
    override fun handleMovement(snake: Snake, boundaries: Boundaries): Snake {
        // 无墙模式：穿越边界
        val newSnake = snake.move()
        return newSnake.wrapAroundBoundaries(boundaries)
    }
    
    override fun checkCollision(snake: Snake, boundaries: Boundaries): Boolean {
        // 无墙模式不检查边界碰撞
        return false
    }
}
```

**学习要点**：
- 策略模式允许在运行时切换算法
- 每个策略封装了特定的行为
- 客户端代码不需要知道具体的实现细节
- 便于添加新的游戏模式

### 4. 密封类（Sealed Class）的状态管理

#### 游戏状态建模
```kotlin
sealed class GameState {
    abstract val gameData: GameData
    
    data class Playing(
        override val gameData: GameData,
        val config: GameConfig,
        val activeEffects: List<GameEffect> = emptyList()
    ) : GameState()
    
    data class Paused(
        override val gameData: GameData,
        val previousState: Playing
    ) : GameState()
    
    data class GameOver(
        override val gameData: GameData,
        val finalScore: Int,
        val reason: GameOverReason
    ) : GameState()
}
```

**学习要点**：
- 密封类提供了类型安全的状态表示
- 编译器可以检查when表达式的穷尽性
- 每个状态可以有不同的属性
- 便于状态转换的管理

### 5. 效果系统设计

#### 接口和实现分离
```kotlin
interface FoodEffect {
    val duration: Long
    val type: EffectType
    
    fun apply(gameState: GameState.Playing): GameState.Playing
    fun isExpired(startTime: Long, currentTime: Long): Boolean
}

// 具体效果实现
class SpeedUpEffect(override val duration: Long = 3000L) : FoodEffect {
    override val type = EffectType.SPEED_UP
    
    override fun apply(gameState: GameState.Playing): GameState.Playing {
        val newConfig = gameState.config.copy(
            initialSpeed = (gameState.config.initialSpeed * 0.7f).toLong()
        )
        return gameState.copy(config = newConfig)
    }
    
    override fun isExpired(startTime: Long, currentTime: Long): Boolean {
        return currentTime - startTime >= duration
    }
}
```

**学习要点**：
- 使用接口定义通用行为
- 每个效果都是独立的类，便于测试和维护
- 效果可以修改游戏状态
- 支持效果的叠加和过期处理

## 架构设计原则

### 1. 单一职责原则（SRP）
- 每个类只负责一个功能
- `GameConfig` 只负责配置管理
- `GameMode` 只定义游戏模式
- `FoodEffect` 只处理食物效果

### 2. 开闭原则（OCP）
- 对扩展开放，对修改关闭
- 新增游戏模式不需要修改现有代码
- 新增食物效果不影响其他效果

### 3. 依赖倒置原则（DIP）
- 依赖抽象而不是具体实现
- 游戏引擎依赖策略接口，而不是具体策略
- 便于单元测试和模块替换

## 性能考虑

### 1. 对象创建优化
```kotlin
// 避免在游戏循环中创建大量对象
class GameEngine {
    private val positionPool = mutableListOf<Position>()
    
    fun getPosition(x: Int, y: Int): Position {
        return if (positionPool.isNotEmpty()) {
            positionPool.removeAt(positionPool.size - 1).apply {
                this.x = x
                this.y = y
            }
        } else {
            Position(x, y)
        }
    }
}
```

### 2. 状态更新优化
```kotlin
// 使用不可变数据结构，避免意外修改
data class GameData(
    val snake: Snake,
    val food: Food,
    val obstacles: List<Obstacle> = emptyList()
) {
    // 提供便捷的更新方法
    fun updateSnake(newSnake: Snake): GameData {
        return copy(snake = newSnake)
    }
}
```

## 测试策略

### 1. 单元测试
```kotlin
@Test
fun testDifficultySpeedCalculation() {
    val baseSpeed = 500L
    val easySpeed = Difficulty.EASY.calculateSpeed(baseSpeed)
    assertEquals(750L, easySpeed)
}

@Test
fun testGameModeCollisionDetection() {
    val strategy = ClassicModeStrategy()
    val snake = Snake(listOf(Position(-1, 5)))
    val boundaries = Boundaries(20, 20)
    
    assertTrue(strategy.checkCollision(snake, boundaries))
}
```

### 2. 集成测试
```kotlin
@Test
fun testGameConfigIntegration() {
    val config = GameConfig(
        gameMode = GameMode.BORDERLESS,
        difficulty = Difficulty.HARD
    )
    
    val engine = SnakeGameEngine(config)
    val initialState = engine.initializeGame()
    
    assertTrue(initialState.gameData.snake.body.size == config.difficulty.initialSnakeLength)
}
```

## 下一步预告

在阶段2中，我们将：
- 实现动画系统，让游戏更加生动
- 创建主题系统，支持多种视觉风格
- 优化用户界面，提升用户体验
- 添加设置界面，让用户可以自定义游戏

这些技术要点为后续的开发奠定了坚实的基础。